---
layout: post
title: 观察者模式
categories: DesignPattern
description: 学习《Head First 设计模式》第二部分《观察者模式》的笔记。
keywords: 设计模式，观察者模式
---

**如下内容是学习《Head First 设计模式》第二部分《观察者模式》所得，主要就是一些原文的摘抄和少量自己的总结。**

### 观察者模式定义

> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

### OO 原则
1. 封装变化

2. 多用组合，少用继承

3. 针对接口编程，不针对实现编程

4. 为交互对象之间的松耦合设计而努力。

### 观察者类图表示
<img src="/images/posts/designpattern/ObserverPattern.png" width="80%" alt="Observer  Pattern UML Class Diagram"/>

### 角色说明
* 抽象主题角色（Subject）：把所有对观察者对象的引用保存在一个集合容器中，每个主题都可有任何数量的观察者，提供接口可增和删观察者对象。也称为被观察者。
* 具体主题角色（ConcreteSubject）：将有关状态存入具体观察者对象，在具体主题的内容状态改变时，给所有登记过的观察者发出通知。也称为具体被观察者。
* 抽象观察者角色（Observer）：为所有观察者定义一个接口，只有一个update方法，在主题状态变化时更新自己。
* 具体观察者角色（ConcreteObserver）：实现抽象观察者橘色要求的更新接口， 以便使本身的状态与主题的状态相协调。若需要，具体观察者角色可以保持一个指向具体主题对象的引用。

### 推模型和拉模型

* 推模型
    主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。

* 拉模型
    主题对象在通知观察者时，只传递少量信息。若观察者需要具体的信息，由观察者主动到主题对象中获取。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样观察者需要获取数据的时候，就可以通过这个引用来获取了。


### 书中示例的 Java 实现源码

[观察者模式实现](https://github.com/qihouying/design-pattern/tree/master/src/main/java/com/design/pattern/observe)


